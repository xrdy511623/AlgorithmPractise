package Greedy

import (
	"AlgorithmPractise/Utils"
	"sort"
)

/*
1.1 发放饼干
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将
这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例1:
输入: g = [1,2,3], s = [1,1]
输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你
应该输出1。

示例2:
输入: g = [1,2], s = [1,2,3]
输出: 2
解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.

提示：
1 <= g.length <= 3 * 10^4
0 <= s.length <= 3 * 10^4
1 <= g[i], s[j] <= 2^31 - 1
*/

/*
思路:
为了满足更多的小孩，要尽量避免饼干尺寸的浪费。
大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。
这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。
可以尝试使用贪心策略，先将饼干数组和小孩数组排序。
然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。
*/

// FindContentChildren 先满足大胃口的孩子
func FindContentChildren(g []int, s []int) int {
	sort.Ints(g)
	sort.Ints(s)
	index, count := len(s)-1, 0
	for i := len(g) - 1; i >= 0; i-- {
		if index >= 0 && g[i] <= s[index] {
			count++
			index--
		}
	}
	return count
}

// FindContentChildrenTwo 也可以先满足胃口小的孩子
func FindContentChildrenTwo(g []int, s []int) int {
	sort.Ints(g)
	sort.Ints(s)
	count, index := 0, 0
	for i := 0; i < len(s); i++ {
		if index < len(g) && s[i] >= g[index] {
			count++
			index++
		}
	}
	return count
}

/*
1.2 摆动序列
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是
因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例1:
输入: [1,7,4,9,2,5]
输出: 6
解释: 整个序列均为摆动序列。

示例2:
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。

示例3:
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
*/

/*
贪心的本质是选择每一阶段的局部最优,从而达到全局最优, 本题符合这个套路，而且举不出反例，所以可以用贪心解决
本题实质其实是让序列有尽可能多的局部峰值。
局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。
*/

// WiggleMaxLength 时间复杂度O(N),空间复杂度O(1)
func WiggleMaxLength(nums []int) int {
	n := len(nums)
	if n <= 1 {
		return n
	}
	preDiff, curDiff := 0, 0
	// 单个元素也是摆动序列，故maxLength初始化为1
	maxLength := 1
	for i := 1; i < n; i++ {
		curDiff = nums[i] - nums[i-1]
		// 只要满足正负数交替出现，则累加最大摆动子序列长度，并更新preDiff为curDiff
		if (curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0) {
			maxLength++
			preDiff = curDiff
		}
	}
	return maxLength
}

/*
1.3 最大子序和
给定一个整数数组nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1]的和最大，为 6。
*/

/*
贪心的思路为局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
从而推出全局最优：选取最大“连续和”
*/

// MaxSubArray 时间复杂度O(N),空间复杂度O(1)
func MaxSubArray(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	if n == 1 {
		return nums[0]
	}
	max := nums[0]
	for i := 1; i < n; i++ {
		if nums[i-1] > 0 {
			// 前一个数大于0，才有累加的价值,否则重新开始计算子序列和
			nums[i] += nums[i-1]
		}
		if max < nums[i] {
			max = nums[i]
		}
	}
	return max
}

/*
1.4 买卖股票的最佳时机II
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）
的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天
接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为0。

提示：
1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4
*/

// MaxProfit 时间复杂度O(N),空间复杂度O(1)
func MaxProfit(prices []int) int {
	maxProfit := 0
	for i := 1; i < len(prices); i++ {
		if profit := prices[i] - prices[i-1]; profit > 0 {
			maxProfit += profit
		}
	}
	return maxProfit
}

/*
1.5 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

示例 2:
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为3的位置。但该位置的最大跳跃长度是0， 所以你永远不可能到达最后一个位置。
*/

// CanJump 时间复杂度O(N),空间复杂度O(1)
func CanJump(nums []int) bool {
	// 最远可到达位置rightMost，初始值为0
	n, rightMost := len(nums), 0
	for i := 0; i < n; i++ {
		// i <= rightMost证明i这个位置可达，然后更新rightMost
		if i <= rightMost {
			rightMost = Utils.Max(i+nums[i], rightMost)
			// 如果rightMost能延伸到数组末尾位置，证明可以跳到末尾
			if rightMost >= n-1 {
				return true
			}
		}
	}
	return false
}

/*
1.6 跳跃游戏II
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是2。从下标为0跳到下标为1的位置，跳1步，然后跳3步到达数组的最后一个位置。
说明: 假设你总是可以到达数组的最后一个位置。
*/

/*
思路:反向查找出发位置
我们的目标是到达数组的最后一个位置，因此我们可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。
如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？直观上来看，我们可以「贪心」地选择距离最后一个位置最远的那个位置，
也就是对应下标最小的那个位置。因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。
找到最后一步跳跃前所在的位置之后，我们继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。
*/

// Jump 时间复杂度O(N*N),空间复杂度O(1)
func Jump(nums []int) int {
	position := len(nums) - 1
	steps := 0
	for position > 0 {
		for i := 0; i < position; i++ {
			if i+nums[i] >= position {
				position = i
				steps++
				break
			}
		}
	}
	return steps
}

/*
思路:正向查找可到达的最大位置
我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加1。
*/

// JumpSimple 时间复杂度O(N),空间复杂度O(1)
func JumpSimple(nums []int) int {
	n := len(nums)
	// 初始化右边界end，当前所能到达的最大位置maxPosition，以及跳跃次数count为0
	end, maxPosition, count := 0, 0, 0
	for i := 0; i < n-1; i++ {
		// 更新当前所能到达的最大位置maxPosition
		maxPosition = Utils.Max(i+nums[i], maxPosition)
		// 当下标移动到右边界时，跳跃次数需要加1，同时更新右边界为maxPosition
		if i == end {
			end = maxPosition
			count++
		}
	}
	return count
}

/*
1.7 K次取反后最大化的数组和
给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引i并将A[i]替换为-A[i]，然后总共重复这个过程K次。（我们可以多次选择同一个索引i。）
以这种方式修改数组后，返回数组可能的最大和。

示例1：
输入：A = [4,2,3], K = 1
输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。

示例 2：
输入：A = [3,-1,0,2], K = 3
输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。

示例3：
输入：A = [2,-3,-1,5,-4], K = 2
输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
提示：

1 <= A.length <= 10000
1 <= K <= 10000
-100 <= A[i] <= 100
*/

/*
思路:
由于我们必须反转k次，那么有不止k个负数的话，我们要反转里面最小的k个，这样数组和sum最大。有不到k个负数的话（数组会变为全部为正），
剩下的次数就反复反转所有数里面绝对值最小的那个(如果剩下偶数次负负得正所以sum不变，奇数次相当于只反转一次最小的那个）
*/

func LargestSumAfterKNegations(nums []int, k int) int {
	sum := 0
	minAbs := 101
	sort.Ints(nums)
	for _, num := range nums {
		minAbs = Utils.MinAbs(minAbs, num)
		if num < 0 && k > 0 {
			sum -= num
			k--
		} else {
			sum += num
		}
	}
	if k > 0 && k%2 == 1 {
		return sum - 2*minAbs
	}
	return sum
}
