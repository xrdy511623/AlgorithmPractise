package sum

import (
	"AlgorithmPractise/Utils"
	"strconv"
)

/*
1.1 连续子数组的最大和
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1]的和最大，为6。
*/

func maxSubArray(nums []int) int {
	for i := 1; i < len(nums); i++ {
		nums[i] += Utils.Max(nums[i-1], 0)
	}
	return Utils.MaxValueOfArray(nums)
}

/*
1.2 字符串相加
给定两个字符串形式的非负整数num1和num2，计算它们的和并同样以字符串形式返回。
你不能使用任何內建的用于处理大整数的库，也不能直接将输入的字符串转换为整数形式。

示例 1：

输入：num1 = "11", num2 = "123"
输出："134"
示例 2：

输入：num1 = "456", num2 = "77"
输出："533"
示例 3：

输入：num1 = "0", num2 = "0"
输出："0"

*/

/*
思路与算法:
本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数
相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过10，则向高位进一位？因此我们只要将这个过程用代码写出来即可。
图:字符串相加.png
具体实现也不复杂，我们定义两个指针i和j分别指向num1和num2的末尾，即最低位，同时定义一个变量add维护当前是否有进位，然后从末尾到开头逐位
相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回0，等价于对位数较短的数字进行了补零操作，
这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码。

复杂度分析
时间复杂度：O(max(len1,len2)),其中len1=num1.length, len2=num2.length,竖式加法的次数取决于较大数的位数。
空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量.
*/

func AddStrings(num1, num2 string) string {
	// 进位值初始值为0
	add := 0
	result := ""
	// 从低位开始相加，每循环一次，索引向左移动一位
	for i, j := len(num1)-1, len(num2)-1; i >= 0 || j >= 0 || add != 0; i, j = i-1, j-1 {
		var x, y int
		if i >= 0 {
			x = int(num1[i] - '0')
		}
		if j >= 0 {
			y = int(num2[j] - '0')
		}
		sum := x + y + add
		result = strconv.Itoa(sum%10) + result
		add = sum / 10
	}
	return result
}
